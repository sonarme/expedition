// Generated by http://code.google.com/p/protostuff/ ... DO NOT EDIT!
// Generated from openrtb.proto

package org.openrtb.mobile;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.ArrayList;
import java.util.List;

import com.dyuproject.protostuff.GraphIOUtil;
import com.dyuproject.protostuff.Input;
import com.dyuproject.protostuff.Message;
import com.dyuproject.protostuff.Output;
import com.dyuproject.protostuff.Schema;

public final class Restrictions implements Externalizable, Message<Restrictions> {

    public static Schema<Restrictions> getSchema() {
        return SCHEMA;
    }

    public static Restrictions getDefaultInstance() {
        return DEFAULT_INSTANCE;
    }

    static final Restrictions DEFAULT_INSTANCE = new Restrictions();


    // non-private fields
    // see http://developer.android.com/guide/practices/design/performance.html#package_inner
    List<String> bcat;
    List<String> badv;

    public Restrictions() {

    }

    // getters and setters

    // bcat

    public List<String> getBcatList() {
        return bcat;
    }

    public void setBcatList(List<String> bcat) {
        this.bcat = bcat;
    }

    // badv

    public List<String> getBadvList() {
        return badv;
    }

    public void setBadvList(List<String> badv) {
        this.badv = badv;
    }

    // java serialization

    public void readExternal(ObjectInput in) throws IOException {
        GraphIOUtil.mergeDelimitedFrom(in, this, SCHEMA);
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        GraphIOUtil.writeDelimitedTo(out, this, SCHEMA);
    }

    // message method

    public Schema<Restrictions> cachedSchema() {
        return SCHEMA;
    }

    static final Schema<Restrictions> SCHEMA = new Schema<Restrictions>() {
        // schema methods

        public Restrictions newMessage() {
            return new Restrictions();
        }

        public Class<Restrictions> typeClass() {
            return Restrictions.class;
        }

        public String messageName() {
            return Restrictions.class.getSimpleName();
        }

        public String messageFullName() {
            return Restrictions.class.getName();
        }

        public boolean isInitialized(Restrictions message) {
            return true;
        }

        public void mergeFrom(Input input, Restrictions message) throws IOException {
            for (int number = input.readFieldNumber(this); ; number = input.readFieldNumber(this)) {
                switch (number) {
                    case 0:
                        return;
                    case 1:
                        if (message.bcat == null)
                            message.bcat = new ArrayList<String>();
                        message.bcat.add(input.readString());
                        break;
                    case 2:
                        if (message.badv == null)
                            message.badv = new ArrayList<String>();
                        message.badv.add(input.readString());
                        break;
                    default:
                        input.handleUnknownField(number, this);
                }
            }
        }


        public void writeTo(Output output, Restrictions message) throws IOException {
            if (message.bcat != null) {
                for (String bcat : message.bcat) {
                    if (bcat != null)
                        output.writeString(1, bcat, true);
                }
            }

            if (message.badv != null) {
                for (String badv : message.badv) {
                    if (badv != null)
                        output.writeString(2, badv, true);
                }
            }
        }

        public String getFieldName(int number) {
            switch (number) {
                case 1:
                    return "bcat";
                case 2:
                    return "badv";
                default:
                    return null;
            }
        }

        public int getFieldNumber(String name) {
            final Integer number = fieldMap.get(name);
            return number == null ? 0 : number.intValue();
        }

        final java.util.HashMap<String, Integer> fieldMap = new java.util.HashMap<String, Integer>();

        {
            fieldMap.put("bcat", 1);
            fieldMap.put("badv", 2);
        }
    };

}
